<?xml version="1.0"?>
<repository xmlns="https://ianjohnson.dev/zig-gobject/extras">
  <namespace name="GObject" version="2.0">
    <function name="callback">
      <parameter name="p_func" type="anytype" />
      <return-value type="Callback" />
      <!-- TODO: validate that p_func is actually a function pointer -->
      <body>return @ptrCast(Callback, p_func);</body>
    </function>
    <function name="registerType">
      <parameter name="Self" type="type" comptime="1" />
      <parameter name="options" type="struct { name: ?[:0]const u8 = null, flags: TypeFlags = .{} }" comptime="1" />
      <return-value type="fn () Type" />
      <!-- TODO: various validations, maybe support class_data? -->
      <body>const self_info = @typeInfo(Self);
if (self_info != .Struct or self_info.Struct.layout != .Extern) {
    @compileError("an instance type must be an extern struct");
}

if (!@hasDecl(Self, "Parent")) {
    @compileError("a class type must have a member named Parent pointing to the parent type");
}
const parent_info = @typeInfo(Self.Parent);
if (parent_info != .Struct or parent_info.Struct.layout != .Extern or !@hasDecl(Self.Parent, "getType")) {
    @compileError("the defined parent type " ++ @typeName(Self.Parent) ++ " does not appear to be a GObject class type");
}

if (!@hasDecl(Self, "Class")) {
    @compileError("a class type must have a member named Class pointing to the class record");
}
const class_info = @typeInfo(Self.Class);
if (class_info != .Struct or class_info.Struct.layout != .Extern) {
    @compileError("a class type must be an extern struct");
}

return struct {
    var registered_type: Type = 0;

    pub fn getType() Type {
        if (registered_type == 0) {
            const info = TypeInfo{
                .class_size = @sizeOf(Self.Class),
                .base_init = if (@hasDecl(Self, "baseInit")) @ptrCast(BaseInitFunc, &amp;Self.baseInit) else null,
                .base_finalize = if (@hasDecl(Self, "baseFinalize")) @ptrCast(BaseFinalizeFunc, &amp;Self.baseFinalize) else null,
                .class_init = if (@hasDecl(Self.Class, "init")) @ptrCast(ClassInitFunc, &amp;Self.Class.init) else null,
                .class_finalize = if (@hasDecl(Self.Class, "finalize")) @ptrCast(ClassFinalizeFunc, &amp;Self.Class.finalize) else null,
                .class_data = null,
                .instance_size = @sizeOf(Self),
                .n_preallocs = 0,
                .instance_init = if (@hasDecl(Self, "init")) @ptrCast(InstanceInitFunc, &amp;Self.init) else null,
                .value_table = null,
            };
            const type_name = if (options.name) |name| name else blk: {
              var self_name: [:0]const u8 = @typeName(Self);
              const last_dot = @import("std").mem.lastIndexOfScalar(u8, self_name, '.');
              if (last_dot) |pos| {
                  self_name = self_name[pos + 1 ..];
              }
              break :blk self_name;
            };
            registered_type = typeRegisterStatic(Self.Parent.getType(), type_name, &amp;info, options.flags);
        }
        return registered_type;
    }
}.getType;</body>
    </function>
    <class name="Object">
      <method name="as">
        <parameter name="p_self" type="*Self" />
        <parameter name="T" type="type" comptime="1" />
        <return-value type="*T" />
        <body>if (T == Self) {
    return p_self;
}

comptime var curr_type = Self;
inline while (@hasDecl(curr_type, "Parent")) {
    curr_type = curr_type.Parent;
    if (curr_type == T) {
        return @ptrCast(*T, p_self);
    }
}

@compileError("type is not guaranteed to be compatible with " ++ @typeName(T));</body>
      </method>
    </class>
  </namespace>
</repository>
