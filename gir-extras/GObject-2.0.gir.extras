<?xml version="1.0"?>
<repository xmlns="https://ianjohnson.dev/zig-gobject/extras">
  <namespace name="GObject" version="2.0">
    <constant name="Interface">
      <doc>The fundamental type from which all interfaces are derived.</doc>
      <value>typeMakeFundamental(2)</value>
    </constant>
    <constant name="Enum">
      <doc>The fundamental type from which all enumeration types are derived.</doc>
      <value>typeMakeFundamental(12)</value>
    </constant>
    <constant name="Flags">
      <doc>The fundamental type from which all flags types are derived.</doc>
      <value>typeMakeFundamental(13)</value>
    </constant>
    <constant name="Boxed">
      <doc>The fundamental type from which all boxed types are derived.</doc>
      <value>typeMakeFundamental(18)</value>
    </constant>
    <function name="registerType">
      <doc>Registers a new class type in the GObject type system.

The `Self` parameter is the instance struct for the type. There are several constraints on this type:

- It must be an `extern struct`, and the first member must be of type `Parent`
- It must have a public declaration named `Parent` referring to the parent type (creating new fundamental types is not currently supported)
- `Parent` must be a valid GObject type
- It must have a public declaration named `Class` referring to the class struct
- `Class` must be an `extern struct`, and the first member must be of type `Parent.Class`

Implementations of lifecycle methods such as `init`, etc. are taken from the corresponding methods in `Self` and `Class`, if available.</doc>
      <parameter name="Self" type="type" comptime="1" />
      <parameter name="options" type="struct { name: ?[:0]const u8 = null, flags: TypeFlags = .{} }" comptime="1" />
      <return-value type="fn () Type" />
      <!-- TODO: various validations, maybe support class_data? -->
      <body>const self_info = @typeInfo(Self);
if (self_info != .Struct or self_info.Struct.layout != .Extern) {
    @compileError("an instance type must be an extern struct");
}

if (!@hasDecl(Self, "Parent")) {
    @compileError("a class type must have a member named Parent pointing to the parent type");
}
const parent_info = @typeInfo(Self.Parent);
if (parent_info != .Struct or parent_info.Struct.layout != .Extern or !@hasDecl(Self.Parent, "getType")) {
    @compileError("the defined parent type " ++ @typeName(Self.Parent) ++ " does not appear to be a GObject class type");
}

if (!@hasDecl(Self, "Class")) {
    @compileError("a class type must have a member named Class pointing to the class record");
}
const class_info = @typeInfo(Self.Class);
if (class_info != .Struct or class_info.Struct.layout != .Extern) {
    @compileError("a class type must be an extern struct");
}
if (!@hasDecl(Self.Class, "Instance") or Self.Class.Instance != Self) {
    @compileError("a class type must have a member named Instance pointing to the instance type");
}

return struct {
    var registered_type: Type = 0;

    pub fn getType() Type {
        if (registered_type == 0) {
            const classInitFunc = struct {
                fn classInit(class: *Self.Class) callconv(.C) void {
                    if (@hasDecl(Self.Class, "parent")) {
                        Self.Class.parent = @ptrCast(*Self.Parent.Class, @alignCast(@alignOf(*Self.Parent.Class), class.peekParent()));
                    }
                    if (@hasDecl(Self.Class, "init")) {
                        Self.Class.init(class);
                    }
                }
            }.classInit;
            const info = TypeInfo{
                .class_size = @sizeOf(Self.Class),
                .base_init = if (@hasDecl(Self, "baseInit")) @ptrCast(BaseInitFunc, &amp;Self.baseInit) else null,
                .base_finalize = if (@hasDecl(Self, "baseFinalize")) @ptrCast(BaseFinalizeFunc, &amp;Self.baseFinalize) else null,
                .class_init = @ptrCast(ClassInitFunc, &amp;classInitFunc),
                .class_finalize = if (@hasDecl(Self.Class, "finalize")) @ptrCast(ClassFinalizeFunc, &amp;Self.Class.finalize) else null,
                .class_data = null,
                .instance_size = @sizeOf(Self),
                .n_preallocs = 0,
                .instance_init = if (@hasDecl(Self, "init")) @ptrCast(InstanceInitFunc, &amp;Self.init) else null,
                .value_table = null,
            };
            const type_name = if (options.name) |name| name else blk: {
              var self_name: [:0]const u8 = @typeName(Self);
              const last_dot = std.mem.lastIndexOfScalar(u8, self_name, '.');
              if (last_dot) |pos| {
                  self_name = self_name[pos + 1 ..];
              }
              break :blk self_name;
            };
            registered_type = typeRegisterStatic(Self.Parent.getType(), type_name, &amp;info, options.flags);
        }
        return registered_type;
    }
}.getType;</body>
    </function>
    <function name="typeMakeFundamental">
      <doc>A translation of the `G_TYPE_MAKE_FUNDAMENTAL` macro, for internal use.</doc>
      <parameter name="x" type="usize" />
      <return-value type="Type" />
      <body>return x &lt;&lt; TYPE_FUNDAMENTAL_SHIFT;</body>
    </function>
    <function name="typeFor">
      <doc>Returns the GObject `Type` corresponding to the given type.</doc>
      <parameter name="T" type="type" comptime="1" />
      <return-value type="Type" />
      <body>const typeInfo = @typeInfo(T);
// Types manually extracted from gtype.h since they don't seem to show up in GIR
if (comptime std.meta.trait.hasFn("getType")(T)) {
    return T.getType();
} else if (T == void) {
    return typeMakeFundamental(1);
} else if (T == i8) {
    return typeMakeFundamental(3);
} else if (T == u8) {
    return typeMakeFundamental(4);
} else if (T == bool) {
    return typeMakeFundamental(5);
} else if (T == c_int) {
    return typeMakeFundamental(6);
} else if (T == c_uint) {
    return typeMakeFundamental(7);
} else if (T == c_long) {
    return typeMakeFundamental(8);
} else if (T == c_ulong) {
    return typeMakeFundamental(9);
} else if (T == i64) {
    return typeMakeFundamental(10);
} else if (T == u64) {
    return typeMakeFundamental(11);
} else if (T == f32) {
    return typeMakeFundamental(14);
} else if (T == f64) {
    return typeMakeFundamental(15);
} else if (comptime isCString(T)) {
    return typeMakeFundamental(16);
} else if (T == *anyopaque or T == *const anyopaque) {
    return typeMakeFundamental(17);
} else if (T == ParamSpec) {
    return typeMakeFundamental(19);
} else if (T == glib.Variant) {
    return typeMakeFundamental(21);
} else if (typeInfo == .Enum and typeInfo.Enum.tag_type == c_int) {
    return Enum;
} else if (typeInfo == .Struct and typeInfo.Struct.backing_integer == c_uint) {
    return Flags;
} else {
    @compileError("unable to determine GObject type for " ++ @typeName(T));
}</body>
    </function>
    <record name="TypeInstance">
      <method name="cast">
        <doc>Casts this to another type, or returns null if this is not an instance of the type.</doc>
        <parameter name="self" type="*Self" />
        <parameter name="T" type="type" comptime="1" />
        <return-value type="?*T" />
        <body>return if (self.isA(T)) self.castUnchecked(T) else null;</body>
      </method>
      <method name="castUnchecked">
        <doc>Casts this to another type, without checking whether such a cast is actually valid.</doc>
        <parameter name="self" type="*Self" />
        <parameter name="T" type="type" comptime="1" />
        <return-value type="*T" />
        <body>return @ptrCast(*T, @alignCast(@alignOf(*T), self));</body>
      </method>
      <method name="isA">
        <doc>Returns whether this is an instance of the given type or some sub-type.</doc>
        <parameter name="self" type="*Self" />
        <parameter name="T" type="type" comptime="1" />
        <return-value type="bool" />
        <body>return typeCheckInstanceIsA(self.castUnchecked(TypeInstance), typeFor(T));</body>
      </method>
    </record>
    <record name="TypeClass">
      <method name="castUnchecked">
        <doc>Casts this to another type, without checking whether such a cast is actually valid.</doc>
        <parameter name="self" type="*Self" />
        <parameter name="T" type="type" comptime="1" />
        <return-value type="*T" />
        <body>return @ptrCast(*T, @alignCast(@alignOf(*T), self));</body>
      </method>
    </record>
    <class name="Object">
      <method name="newFrom">
        <doc>Creates a new instance of this object type with the given properties.</doc>
        <parameter name="properties" type="anytype" />
        <return-value type="*Self" />
        <body>const typeInfo = @typeInfo(@TypeOf(properties)).Struct;
const n_props = typeInfo.fields.len;
var names: [n_props][*:0]const u8 = undefined;
var values: [n_props]Value = undefined;
inline for (typeInfo.fields, 0..) |field, i| {
    names[i] = field.name ++ "\x00";
    values[i] = Value.wrap(@field(properties, field.name));
}
defer for (&amp;values) |*value| value.unset();
// TODO: the names parameter should actually be [*][*:0]const u8
return Object.newWithProperties(Self.getType(), n_props, @ptrCast([*][*:0]u8, &amp;names), &amp;values).castUnchecked(Self);</body>
      </method>
      <method name="as">
        <doc>Safely casts this object to an instance of `T`, emitting a compilation error if the safety of the cast cannot be guaranteed.</doc>
        <parameter name="self" type="*Self" />
        <parameter name="T" type="type" comptime="1" />
        <return-value type="*T" />
        <body>if (T == Self) {
    return self;
}

comptime var curr_type = Self;
inline while (@hasDecl(curr_type, "Parent")) {
    curr_type = curr_type.Parent;
    if (curr_type == T) {
        return self.castUnchecked(T);
    }
}

@compileError("type is not guaranteed to be compatible with " ++ @typeName(T));</body>
      </method>
    </class>
    <record name="ObjectClass">
      <method name="as">
        <doc>Safely casts this class to an instance of `T`, emitting a compilation error if the safety of the cast cannot be guaranteed.</doc>
        <parameter name="class" type="*Self" />
        <parameter name="T" type="type" comptime="1" />
        <return-value type="*T" />
        <body>if (T == Self) {
    return class;
}

comptime var curr_type = Self;
inline while (@hasDecl(curr_type.Instance, "Parent")) {
    curr_type = curr_type.Instance.Parent.Class;
    if (curr_type == T) {
        return @ptrCast(*T, @alignCast(@alignOf(*T), class));
    }
}

@compileError("type is not guaranteed to be compatible with " ++ @typeName(T));</body>
      </method>
      <methods-code>// Special case not exposed through normal GIR
pub usingnamespace TypeClassMethods(Self);</methods-code>
    </record>
    <record name="Value">
      <function name="new">
        <doc>Returns a new `Value` intended to hold data of the given type.</doc>
        <parameter name="T" type="type" comptime="1" />
        <return-value type="Self" />
        <body>var value = std.mem.zeroes(Self);
_ = value.init(typeFor(T));
return value;</body>
      </function>
      <function name="wrap">
        <doc>Wraps a value in a `Value`.

This does not take ownership of the value (if applicable).</doc>
        <parameter name="value" type="anytype" />
        <return-value type="Self" />
        <body>comptime var T = @TypeOf(value);
const typeInfo = @typeInfo(T);
var wrapped: Value = undefined;
if (T == i8) {
    wrapped = new(T);
    wrapped.setSchar(value);
} else if (T == u8) {
    wrapped = new(T);
    wrapped.setUchar(value);
} else if (T == bool) {
    wrapped = new(T);
    wrapped.setBoolean(value);
} else if (T == c_int) {
    wrapped = new(T);
    wrapped.setInt(value);
} else if (T == c_uint) {
    wrapped = new(T);
    wrapped.setUint(value);
} else if (T == c_long) {
    wrapped = new(T);
    wrapped.setLong(value);
} else if (T == c_ulong) {
    wrapped = new(T);
    wrapped.setUlong(value);
} else if (T == i64) {
    wrapped = new(T);
    wrapped.setInt64(value);
} else if (T == u64) {
    wrapped = new(T);
    wrapped.setUint64(value);
} else if (T == f32) {
    wrapped = new(T);
    wrapped.setFloat(value);
} else if (T == f64) {
    wrapped = new(T);
    wrapped.setDouble(value);
} else if (comptime isCString(T)) {
    wrapped = new(T);
    wrapped.setString(value);
} else if (T == *anyopaque or T == *const anyopaque) {
    wrapped = new(T);
    wrapped.setPointer(value);
} else if (T == ParamSpec) {
    wrapped = new(T);
    wrapped.setParam(value);
} else if (T == glib.Variant) {
    wrapped = new(T);
    wrapped.setVariant(value);
} else if (typeInfo == .Enum and typeInfo.Enum.tag_type == c_int) {
    wrapped = new(T);
    wrapped.setEnum(@enumToInt(value));
} else if (typeInfo == .Struct and typeInfo.Struct.backing_integer == c_uint) {
    wrapped = new(T);
    wrapped.setFlags(@bitCast(c_uint, value));
} else if (typeInfo == .Pointer and comptime std.meta.trait.hasFn("getType")(typeInfo.Pointer.child)) {
    wrapped = new(typeInfo.Pointer.child);
    if (typeInfo.Pointer.child.getType() == Boxed) {
        wrapped.setBoxed(value);
    } else {
        wrapped.setObject(@ptrCast(*Object, value));
    }
} else {
    @compileError("cannot construct Value containing " ++ @typeName(T));
}
return wrapped;</body>
      </function>
    </record>
    <!-- Implementation details -->
    <function name="isCString" private="1">
      <parameter name="T" type="type" comptime="1" />
      <return-value type="bool" />
      <body>return switch (@typeInfo(T)) {
    .Pointer => |info| switch (info.size) {
        .One => switch (@typeInfo(info.child)) {
            .Array => |child| child.child == u8 and std.meta.sentinel(info.child) == @as(u8, 0),
            else => false,
        },
        .Many => info.child == u8 and std.meta.sentinel(T) == @as(u8, 0),
        else => false,
    },
    else => false,
};</body>
    </function>
  </namespace>
</repository>
